"""2D product composition experiments

Compute metrics from samples generated by the 'train_script_product' script
"""
from argparse import ArgumentParser
import pickle
from pathlib import Path
import numpy as np

from src.simple_distributions.metrics import (
    gmm_metric,
    wasserstein_metric,
    ll_prod_metric,
)


def main():
    args = parse_args()
    gmm_metrics = dict()
    w2_metrics = dict()
    ll_metrics = dict()
    sample_files = args.samples_path.glob("samples*.p")
    for sample_file in sample_files:
        samples = pickle.load(open(sample_file, "rb"))
        # True data distribution
        target = samples["target"]
        for name, sample in samples.items():
            gmm = gmm_metric(target, sample)
            add_metric(gmm_metrics, name, gmm)
            # add_metric(gmm_metrics, name, 1.0)

            w2 = wasserstein_metric(target, sample)
            add_metric(w2_metrics, name, w2)
            # add_metric(w2_metrics, name, 1.0)

            ll = ll_prod_metric(sample)
            add_metric(ll_metrics, name, ll)

    gmm_stats = stats(gmm_metrics)
    w2_stats = stats(w2_metrics)
    ll_stats = stats(ll_metrics)
    print_tex_table(comb_stats(ll_stats, w2_stats, gmm_stats))


def print_stats(stats, metric_name):
    print(metric_name)
    for name, stat in stats.items():
        mean, std = stat
        print(f"\t{name}: {mean} +/- {std}")


# & Reverse & $-6.64 \pm 1.58$ & 0.3649112 & . \\
def comb_stats(ll, w2, gmm):
    comb = dict()
    for name in ll.keys():
        comb[name] = (ll[name], w2[name], gmm[name])
    return comb


def print_tex_table(stats):
    print("EBM")
    for name, (ll, w2, gmm) in stats.items():
        if name == "target" or "diff" in name:
            continue
        print(
            f"& {NAME_CONV[name]}\t\t & ${ll[0]:.2f} \\pm {ll[1]:.2f}$ & ${w2[0]:.2f} \\pm {w2[1]:.2f}$ & ${gmm[0]:.3f} \\pm {gmm[1]:.5f}$ \\\\"
        )
    print("Diff")
    for name, (ll, w2, gmm) in stats.items():
        if name == "target" or "ebm" in name:
            continue
        print(
            f"& {NAME_CONV[name]}\t\t & ${ll[0]:.2f} \\pm {ll[1]:.2f}$ & ${w2[0]:.2f} \\pm {w2[1]:.2f}$ & ${gmm[0]:.3f} \\pm {gmm[1]:.5f}$ \\\\"
        )


def stats(metrics):
    stats_ = dict()
    for name, vals in metrics.items():
        stats_[name] = mean_and_std(vals)
    return stats_


def mean_and_std(vals: list):
    vals_ = np.array(vals)
    return vals_.mean(), vals_.std()


def add_metric(dict_, key, val):
    if dict_.get(key) is None:
        dict_[key] = [val]
    else:
        dict_[key].append(val)


def parse_args():
    parser = ArgumentParser(prog="compute_metrics_product")
    parser.add_argument("--samples_path", default=None, type=Path)
    return parser.parse_args()


NAME_CONV = {
    "ebm_hmc": "HMC",
    "ebm_reverse": "Reverse",
    "ebm_uhmc": "U-HMC",
    "ebm_ula": "U-LA",
    "ebm_mala": "LA",
    "diff_hmc4eff": "HMC-4(eff)",
    "diff_hmc3": "HMC-3",
    "diff_reverse": "Reverse",
    "diff_hmc5": "HMC-5",
    "diff_hmc10": "HMC-10",
    "diff_uhmc": "U-HMC",
    "diff_ula": "U-LA",
    "diff_mala3": "LA-3",
    "diff_mala5": "LA-5",
    "diff_mala10": "LA-10",
}

if __name__ == "__main__":
    main()
